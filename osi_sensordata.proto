syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";
import "osi_detectedlandmark.proto";
import "osi_detectedlane.proto";
import "osi_detectedobject.proto";
import "osi_detectedoccupant.proto";
import "osi_groundtruth.proto";
import "osi_sensorview.proto";
import "osi_featuredata.proto";
import "osi_hostvehicledata.proto";

package osi;

//
// \brief The virtual sensor information derived from \c GroundTruth and 
// potentially processed by sensor-models.
//
// The virtual sensor information is supposed to imitate the output of a real 
// sensor. All information regarding the environment is given with respect to 
// the sensor coordinate system specified in \c SensorData::mounting_position. 
// When simulating multiple sensors, each sensor has an individual copy of the 
// \c SensorData interface. This allows an independent treatment of the sensors.
//
message SensorData
{  
    // The ID of the sensor at host vehicle's mounting_position.
    //
    // This ID can equal \c DetectionHeader::sensor_id, if SensorData holds only
    // data from one sensor/sensor model.
    //
    optional Identifier sensor_id = 1;

    // The timestamp of the sensor data. Zero time is arbitrary but must be
    // identical for all messages. Zero time does not need to coincide with
    // the unix epoch. Recommended is the starting time point of the
    // simulation.
    //
    // \note This is the point in time that the sensor data message becomes
    // available to the rest of the system (i.e. the driving functions), so
    // it corresponds with the sending time and thus takes the latency of
    // internal processing of the sensor into account. Latencies of bus
    // communications, etc., that occur after the sensor output have to be
    // applied on top of this, if needed.
    //
    // The time that the actual measurement was performed (which will usually
    // correspond with the timestamp of the GroundTruth the sensor model
    // processed to arrive at these results) can be found in the additional
    // field \c SensorData::last_measurement_time.
    //
    // For an ideal zero latency sensor the two timestamps would be the same
    // and would correspond with the timestamp from the current GroundTruth
    // message.
    //
    // For a sensor model that does not know its own internal latencies (e.g.
    // a dumb sensor with no internal time concept), the two timestamps might
    // also be identical, but delayed from the GroundTruth timestamp.
    //
    optional Timestamp timestamp = 2;

    // Ground truth w.r.t. global coordinate system
    //
    // This is the ground truth that is provided to the sensor model by the
    // simulation environment.
    // \note Should be used as constant in the sensor models.
    // 
    optional GroundTruth global_ground_truth = 3;
    
    // Sensor view w.r.t. the sensor coordinate system
    //
    // This provides additional data to the sensor model as configured in
    // the sensor input configuration.  All data is relative to the sensor
    // both in terms of the coordinate system, as well as the content.
    // \note Should be used as constant in the sensor models.
    // 
    optional SensorView sensor_view = 4;
    
    // The ID of the host vehicle in the ground_truth data.
    //    
    optional Identifier host_vehicle_id = 5;
    
    // Mounting position of the sensor (origin and orientation of the sensor 
    // frame). Both origin and orientation are given in and with respect to the 
    // host vehicle coordinate system (see: \c Vehicle vehicle reference
    // point) [1].
    //
    // The sensor frame's x-axis is pointing in the central viewing direction of 
    // the sensor. It is the angle bisector of the sensor's horizontal and 
    // vertical field of view. The terms horizontal and vertical must be 
    // understood as names for the two principal planes of the sensor's field of 
    // view (relative to the sensor frame's orientation), which do not have to
    // be horizontal or vertical in the strict sense of being parallel or 
    // perpendicular to the local gravitational vector. The horizontal field
    // of view defines the sensor frame's xy-plane and the vertical field
    // of view defines the xz-plane. The sensor frame is right-handed and the 
    // z-axis is pointing in an upward direction.
    //
    // The sensor frame uses cartesian coordinates. The sensor frame's origin is
    // identical to sensor detection frame's origin. Detections are defined in 
    // the sensor detection frame which uses e.g. spherical coordinates.
    //
    // \par References: 
    // [1] DIN ISO 8855:2013-11
    //
    optional MountingPosition mounting_position = 6;

    // The root mean squared error of the mounting position.
    //
    optional MountingPosition mounting_position_rmse = 7;

    // The timestamp of the last real-world measurement (e.g. GT input) that
    // this set of sensor data takes into account.  This in effect is the last
    // time instance of reality the measurements correspond to.  See field
    // \c SensorData::timestamp for a detailed discussion.  This value is also
    // the upper bound to the \c DetectedObjectHeader::measurement_time and the
    // feature data \c SensorDetectionHeader::measurement_time fields.
    // 
    optional Timestamp last_measurement_time = 8;

    // General information about the \c DetectedObject .
    // 
    optional DetectedEntityHeader object_header = 100;
    
    // The list of objects detected by the sensor as perceived by the sensor.
    //
    repeated DetectedObject object = 9;
    
    // General information about the \c DetectedTrafficSign .
    // 
    optional DetectedEntityHeader traffic_sign_header = 101;

    // The list of traffic signs detected by the sensor
    //
    repeated DetectedTrafficSign traffic_sign = 10;
        
    // General information about the \c DetectedTrafficLight .
    // 
    optional DetectedEntityHeader traffic_light_header = 102;

    // The list of traffic lights detected by the sensor
    // 
    repeated DetectedTrafficLight traffic_light = 11;

    // General information about the \c DetectedRoadMarking .
    // 
    optional DetectedEntityHeader road_marking_header = 103;

    // The list of road marking detected by the sensor.
    // This excludes lane boundary markings.
    //
    repeated DetectedRoadMarking road_marking = 12;
        
    // General information about the \c DetectedLane .
    // 
    optional DetectedEntityHeader lane_header = 104;

    // The list of lane detected by the sensor
    // 
    repeated DetectedLane lane = 13;
        
    // General information about the \c DetectedLaneBoundary .
    // 
    optional DetectedEntityHeader lane_boundary_header = 105;

    // The list of lane boundary markings detected by the sensor.
    //
    repeated DetectedLaneBoundary lane_boundary = 14;
        
    // General information about the \c DetectedOccupant .
    // 
    optional DetectedEntityHeader occupant_header = 106;

    // The list of occupants of the host vehicle
    // 
    repeated DetectedOccupant occupant = 16;

    // The ID of the lane the host vehicle travels on in the DetectedLane data,
    // relative to the sensor.
    //
    optional Identifier host_vehicle_lane_id = 15;
    
    // Low level feature data interface.
    //
    // Low Level feature data is optionally provided by sensor models that
    // model sensors giving access to this low level data, i.e. data prior to
    // object hypothesis and tracking.
    //
    optional FeatureData feature_data = 17;
    
    // Host Vehicle Data
    //
    // Host vehicle data is data that the host vehicle knows about itself,
    // e.g. from location sensors, internal sensors and ECU bus data, etc.,
    // that is made available to sensors as input.
    //
    optional HostVehicleData host_vehicle_data_id = 18;
}

//
// \brief The header attributes of each detected entity.
//
message DetectedEntityHeader
{
    // Time stamp at which the measurement was taken (not the time at which it
    // was processed or at which it is transmitted) in the global synchronized
    // time.
    //
    // \note See SensorData::timestamp and SensorData::last_measurement_time
    // for detailed discussions on the semantics of time-related fields.
    //
    optional Timestamp measurement_time = 1;

    // Continuous up counter to identify the cycle.
    //
    optional uint32 cycle_counter = 2;

    // Data Qualifier expresses to what extent the content of this event can be
    // relied on.
    //
    optional DataQualifier data_qualifier = 3;

    //
    // \brief Data qualifier communicates the overall availability of the
    // interface.
    //
    enum DataQualifier
    {
        // Unknown (must not be used in ground truth).
        //
        DATA_QUALIFIER_UNKNOWN = 0;

        // Other (unspecified but known).
        //
        DATA_QUALIFIER_OTHER = 1;

        // Data is available.
        //
        DATA_QUALIFIER_AVAILABLE = 2;

        // Reduced data is available.
        //
        DATA_QUALIFIER_AVAILABLE_REDUCED = 3;

        // Data is not available.
        //
        DATA_QUALIFIER_NOT_AVAILABLE = 4;

        // Sensor is blind.
        //
        DATA_QUALIFIER_BLINDNESS = 5;

        // Sensor temporary available.
        //
        DATA_QUALIFIER_TEMPORARY_AVAILABLE = 6;
    }
}
