syntax = "proto2";

option optimize_for = SPEED;

package osi3;

//
// \brief A description for the steeringwheel.
//
message Steeringwheel
{
    // Angle of the steeringwheel. 
    //
    // Unit in rad: 0=Central (Straight); Left>0; 0>Right.
    //
    optional double angle = 1;

    // Angle-speed of the steeringwheel.
    //
    // Unit in rad/s: 0=Central (Straight); Left>0; 0>Right.
    //
    optional double angular_speed = 2;

    // Torque of the steeringwheel to the hand.
    //
    // Unit in Nm: 0=Central (Straight); Left>0; 0>Right.
    //
    optional double torque = 3;
}

//
// \brief A description for the positions of the pedals.
//
//
message Pedalry
{
    // Position of the acceleration-pedal.
    // 0-100 (percentage of position: Unpressed - fully pressed)
    //
    optional double pedal_position_acceleration = 1;

    // Position of the brake-pedal.
    // 0-100 (percentage of position: Unpressed - fully pressed)
    //
    optional double pedal_position_brake = 2;

    // Position of the clutch-pedal.
    // 0-100 (percentage of position: Unpressed - fully pressed)
    //
    optional double pedal_position_clutch = 3;
}

//
// \brief This is a message to describe, which trajectory the vehicle should follow.
//
//
message Trajectory
{
    // Contains the timestamp where the trajectorypoint should be reached.
    // In [s].
    //
    optional Timestamp timestamp = 1;

    // Contains the X-Position the vehicle should be at the timestamp.
    //
    optional double targeted_pos_x = 2;

    // Contains the Y-Position the vehicle should be at the timestamp.
    //
    optional double targeted_pos_y = 3;

    // Direction of the vehicle at the timestamp.
    // In [Rad].
    //
    optional double trackangle = 4;

    // Contains the curvature at the timestamp.
    // In [1/m].
    //
    optional double curvature = 5;

    // Contains the curvaturechange at the timestamp.
    // In [1/m*s].
    //
    optional double curvaturechange = 6;

    // Contains the velocity of the vehicle at the timestamp.
    // In [m/s].
    //
    optional double velocity = 7;

    // Contains the acceleration of the vehicle at the timestamp.
    // In [m/s^2].
    //
    optional double acceleration = 8;
    
    // Contains the interpolation method.
    //
    optional InterpolationMethod interpolation_method = 9;
    
    // Contains the interpolation method.
    //
    enum InterpolationMethod
    {
        // Stay on the actual lane.
        //
        INTERPOLATION_METHOD_LINEAR = 0;

        // Change to the left.
        //
        INTERPOLATION_METHOD_CUBIC = 1;
    }
}

// The actual gear of the car.
//
enum Gear
{
    // The actual gear was not calculated by the dynamicmodell.
    //
    GEAR_UNKNOWN = 0;

    // The actual gear is 1.
    //
    GEAR_1 = 1;

    // The actual gear is 2.
    //
    GEAR_2 = 2;

    // The actual gear is 3.
    //
    GEAR_3 = 3;

    // The actual gear is 4.
    //
    GEAR_4 = 4;

    // The actual gear is 5.
    //
    GEAR_5 = 5;

    // The actual gear is 6.
    //
    GEAR_6 = 6;

    // The actual gear is 7.
    //
    GEAR_7 = 7;

    // The actual gear is 8.
    //
    GEAR_8 = 8;

    // The actual gear is 9.
    //
    GEAR_9 = 9;

    // The car is in idling-mode.
    //
    GEAR_IDLING = 10;

    // The car is in reverse-mode.
    //
    GEAR_REVERSE = 11;

    // The car is in automatic-driving-mode.
    //
    GEAR_D = 20;

    // The car is in automatic-idling-mode.
    //
    GEAR_N = 21;

    // The car is in automatic-parking-mode.
    //
    GEAR_P = 22;

    // The car has an automatic transmission, but the driver shifts up by his own.
    //
    GEAR_UP = 30;

    // The car has an automatic transmission, but the driver shifts by his own.
    //
    GEAR_MID = 31;

    // The car has an automatic transmission, but the driver shifts down by his own.
    //
    GEAR_DOWN = 32;
}

//
// \brief A 3D-vector for color-description regarding the RGB-format.
// More information: https://en.wikipedia.org/wiki/RGB_color_model.
//
message ColorformatRGB
{
    // The part of red.
    // Values from 0 to 255.
    //
    optional uint32 rgb_red = 1;

    // The part of green.
    // Values from 0 to 255.
    //
    optional uint32 rgb_green = 2;

    // The part of blue.
    // Values from 0 to 255.
    //
    optional uint32 rgb_blue = 3;
}
