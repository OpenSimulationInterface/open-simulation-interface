syntax = "proto2";

option optimize_for = SPEED;

package osi3;

//
// \brief A description for the steeringwheel.
//
message Steeringwheel
{
    // Angle of the steeringwheel. 
	//
	// Unit in Rad [-pi, pi]: 0=Central (Straight); Left>0; 0>Right.
    //
    optional double angle = 1;

    // Angle-speed of the steeringwheel.
	//
	// Unit in rad/s [-pi/s, pi/s]: 0=Central (Straight); Left>0; 0>Right.
    //
    optional double anglespeed = 2;

    // Torque of the steeringwheel to the hand.
	//
	// Unit in Nm: 0=Central (Straight); Left>0; 0>Right.
    //
    optional double torque = 3;
}

//
// \brief A description for the positions of the pedals.
//
//
message Pedalry
{
	// Position of the acceleration-pedal.
	// 0-100 (percentage of position: Unpressed - fully pressed)
    //
    optional double pedalposition_acceleration = 1;

	// Position of the brake-pedal.
	// 0-100 (percentage of position: Unpressed - fully pressed)
    //
    optional double pedalposition_brake = 2;
	
	// Position of the clutch-pedal.
	// 0-100 (percentage of position: Unpressed - fully pressed)
    //
    optional double pedalposition_clutch = 3;
}

//
// \brief This is a message to describe, which trajectory the vehicle should follow.
//
//
message Trajectory
{
	// Contains the timestamp where the trajectorypoint should be reached.
	// In [s].
    //
    optional double timestamp = 1;
	
	// Contains the X-Position the vehicle should be at the timestamp.
    //
    optional double targeted_PosX = 2;

	// Contains the Y-Position the vehicle should be at the timestamp.
    //
    optional double targeted_PosY = 3;

	// Direction of the vehicle at the timestamp.
	// In [Rad].
    //
    optional double trackangle = 4;

	// Contains the curvature at the timestamp.
	// In [1/m].
    //
    optional double curvature = 5;

	// Contains the curvaturechange at the timestamp.
	// In [1/m*s].
    //
    optional double curvaturechange = 6;

	// Contains the velocity of the vehicle at the timestamp.
	// In [m/s].
    //
    optional double velocity = 7;

	// Contains the acceleration of the vehicle at the timestamp.
	// In [m/s^2].
    //
    optional double acceleration = 8;

	// Contains the interpolation method.
    //
    enum interpolation_method
    {
        // Stay on the actual lane.
        //
        LINEAR = 0;

        // Change to the left.
        //
        CUBIC = 1;
	}
}

//
// \brief This is a description of possible gears.
//
//
message Gear
{
	// The actual gear of the car.
    //
    enum Gear
    {
        // The actual gear was not calculated by the dynamicmodell.
        //
        GEAR_UNKNOWN = 0;

        // The actual gear is 1.
        //
        GEAR_1 = 1;

        // The actual gear is 2.
        //
        GEAR_2 = 2;

		// The actual gear is 3.
        //
        GEAR_3 = 3;

		// The actual gear is 4.
        //
        GEAR_4 = 4;

        // The actual gear is 5.
        //
        GEAR_5 = 5;

		// The actual gear is 6.
        //
        GEAR_6 = 6;

		// The actual gear is 7.
        //
        GEAR_7 = 7;

        // The actual gear is 8.
        //
        GEAR_8 = 8;

		// The actual gear is 9.
        //
        GEAR_9 = 9;
		
		// The car is in idling-mode.
        //
        GEAR_IDLING = 10;

		// The car is in reverse-mode.
        //
        GEAR_REVERSE = 11;

		// The car is in automatic-driving-mode.
        //
        GEAR_D = 20;

		// The car is in automatic-idling-mode.
        //
        GEAR_N = 21;

		// The car is in automatic-parking-mode.
        //
        GEAR_P = 22;

		// The car has an automatic transmission, but the driver shifts up by his own.
        //
        GEAR_Up = 30;

		// The car has an automatic transmission, but the driver shifts by his own.
        //
        GEAR_MID = 31;

		// The car has an automatic transmission, but the driver shifts down by his own.
        //
        GEAR_DOWN = 32;
	}
}

//
// \brief A 3D-vector for color-description regarding the RGB-format.
// More information: https://en.wikipedia.org/wiki/RGB_color_model.
//
message ColorformatRGB
{
	// The part of red.
	// Values from 0 to 255.
    //
    optional uint32 rgb_red = 1;

	// The part of green.
	// Values from 0 to 255.
    //
    optional uint32 rgb_green = 2;
	
	// The part of blue.
	// Values from 0 to 255.
    //
    optional uint32 rgb_blue = 3;
}

//
// \brief A description for highly automated driving (SAE Level 3).
//
//
message AdasSAELevel3
{
	// Activationstate of the function.
    //
    optional bool is_activated = 1;

	// This is the speed the function targets.
	// E.g.: At the point of activation, the actual speed could be 80 km/h, 
	// but the function tries to accelerate to 130 km/h.
	// In [km/h].
    //
    optional double targeted_speed = 2;
}

//
// \brief A description for the function longitudinal control.
//
//
message LongitudinalControl
{
	// Activationstate of the function.
    //
    optional bool is_activated = 1;

	// This is the speed the function targets.
	// E.g.: At the point of activation, the actual speed could be 80 km/h, 
	// but the function tries to accelerate to 130 km/h.
	// In [km/h].
    //
    optional double targeted_speed = 2;

	// The timegap describes the minimumdistance to the next vehicle in front.
	// In [s].
    //
    optional bool timegap = 3;
}

//
// \brief A description for the function lateral control.
//
//
message LateralControl
{
	// Activationstate of the function.
    //
    optional bool is_activated = 1;
}

//
// \brief A description for the function emergency brake assistant.
//
//
message EmergencyBrakeAssistant
{
	// Activationstate of the function.
    //
    optional bool is_activated = 1;
}
