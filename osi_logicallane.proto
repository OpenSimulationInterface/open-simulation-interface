syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";
import "osi_lane.proto";

package osi3;

//
// \brief A reference line for defining a non-euclidean ST coordinate system
//
// A reference line is a 3D polyline, used for generating a non-euclidean
// ST coordinate system.
//
// Notes on design decisions:
// - This is a polyline, and not some more complex curve. The advantage of a
//   polyline is that it is very simple to generate from various map formats,
//   and it is also easy to handle. The downside is that a polyline has no
//   direct curvature, and even the angle is not continuous (only C0 smooth).
//   In the author's experience, the benefits of a polyline outweigh the costs.
//
// TODO Test whether the current definition is good enough for wide roads with
// strong curvature (e.g. roundabouts with several lanes).
//
message ReferenceLine
{
    // The ID of the logical lane.
    //
    // \note Note ID is global unique.
    //
    // \rules
    // is_globally_unique
    // \endrules
    //
    optional Identifier id = 1;

    // Points comprising the polyline.
    //
    // At least 2 points must be given.
    // The polyline is defined as the lines between consecutive points.
    // Each point has an S coordinate. There are a few requirements on the S
    // position:
    // - Later points in the list must have strictly larger S coordinates than
    //   earlier points.
    // - For consecutive points, the S difference between them  must be at
    //   least as large as the 2D euclidean distance between the points (2D
    //   distance == euclidean distance between the points taking only X and Y
    //   into account).
    // - The S distance between two points may be larger than the 2D euclidean
    //   distance, but should be not much larger. It is allowed to be larger if
    //   the underlying reference line (e.g. in an OpenDRIVE map) is a curve,
    //   and thus the sampled road has a smaller length than the original
    //   curve.
    //
    // Together, these rules allow directly putting OpenDRIVE S coordinates
    // into an OSI ReferenceLine.
    //
    // Between two ReferenceLinePoints, both the world coordinate and the S
    // coordinate is interpolated linearly. So each S value uniquely describes
    // a point on the polyline.
    //
    // For the purpose of this discussion, let's call the S position of the
    // first point sStart, and the S position of the last point sEnd.
    //
    // For some purposes, S positions outside the normally defined range (i.e.
    // outside [sStart,sEnd]) need to be defined. For this purpose, the first
    // line of the polyline is infinitely extended in negative S direction.
    // Similarly, the last line of the polyline is infinitely extended beyond
    // the last point. The S value of points outside [sStart,sEnd] is defined
    // by the euclidean 2D distance from the start or end point, respectively.
    // So if sStart = 15, and a point is on the line extended from the start
    // position, with a 2D euclidean distance of 10 from the first point, then
    // it has an S position of 5.
    //
    // A point is "before" the reference line, if its s coordinate is < sStart.
    // A point is "after" the reference line, if its s coordinate is > sEnd.
    //
    // To describe points that are not directly on the polyline, a T
    // coordinate is added. T is the signed 2D distance (i.e. hypot(A.X-B.X,
    // A.Y-B.Y), if A and B are the two points) between the point to describe
    // and the nearest point on the polyline (this point might either be on a
    // line segment or at an edge between two line segments). The distance is
    // positive if the point is left of the polyline (in definition direction),
    // negative if it is right of it. Note that the "nearest point on the
    // polyline" is calculated in 3D, in order to choose the correct point for
    // 3D curves (think reference lines for roads in parking decks). If there
    // are several "nearest points", the one with the smallest S coordinate on
    // the polyline is chosen.
    //
    // Sometimes an angle to a reference line is needed. This shall be defined
    // as follows:
    // First the nearest point on the polyline is determined, as described
    // above. If this point is on a line segment, then the angle is calculated
    // relative to the line segment on which the reference point lays.
    // If the nearest point is at the edge between line segments, then the
    // angle of the following line shall be chosen.
    //
    // Notes on OpenDRIVE compatibility:
    // Ideally, one would want the polyline to be fully compatible with
    // OpenDRIVE, so that calculations done for OpenDRIVE directly match those
    // in OSI. There are a few difficulties with this:
    // - The T coordinate is nearly the same as for OpenDRIVE, but
    //   unfortunately not perfectly. In OpenDRIVE, if the road is tilted using
    //   superElevation, then the t coordinate system is tilted along, so the T
    //   coordinate is no longer calculated in the XY plane (as proposed for
    //   OSI). It doesn't seem feasable to implement the same tilting for OSI,
    //   so simulation tools will have to consider superElevation and convert
    //   the T coordinate accordingly.
    // - The angle will not be perfectly the same, due to the use of line
    //   segments in OSI, and curves in OpenDRIVE. In the authors opinion, the
    //   difference will be negligible if the poly_line is suitably sampled.
    //
    // Notes on design decisions:
    // - The S coordinate is included directly, both for OpenDRIVE
    //   compatibility, and to speed up calculations.
    // - The rules on S coordinates (e.g. the calculation in 2D space) are
    //   there to ensure OpenDRIVE compatibility.
    // - The rules on T coordinates are there to ensure OpenDRIVE compatibility
    //   for lanes without superelevation, and to make it easier to convert
    //   between OSI and OpenDRIVE in case superelevation is present.
    //
    // TODO Describe needed precision.
    // TODO Describe how large angles between line segments are allowed to be.
    //
    repeated ReferenceLinePoint poly_line = 2;

    // A point on the reference line
    message ReferenceLinePoint {
        // A world position
        optional Vector3d world_position = 1;

        // S position on the reference line
        optional double s_position = 2;
    }
}

// Like a LaneBoundary, but with a reference and ST positions.
//
// Notes on design decisions:
// - The LogicalLaneBoundary has ST coordinates, and is thus a separate type
//   from LaneBoundary.
//   Advantages of this decision:
//   - Calculations like getting the lane width at a position are easy, since
//     one can just get the boundary points of the left and right boundary at
//     the desired S position (via linear interpolation), and calculate the
//     width from the two points. Also getting something like the distance to
//     the lane border is very easy.
//   - No centerline of the lane is necessary, since this can very easily be
//     generated from the boundaries.
//   Disadvantages of this decision:
//   - Lane boundaries cannot be shared with physical lanes. This results in
//     more data needed. This can mostly be mitigated by only transmitting the
//     lane boundaries during initialization (e.g. via the OSMP GroundTruthInit
//     message).
// - The LogicalLaneBoundary contains all data directly which an agent model is
//   likely to need. It does not include information normally only used by
//   sensor models (e.g. the exact length of the color markings on the road).
//   This information can be gotten from the physical lane referenced in the
//   LogicalLane, if needed.
//
// TODO To Discuss: It would be entirely possible to add ST coordinates also to
// LaneBoundary. Then no separate type would be needed. However, it is unclear if
// the additional overhead is acceptable for sensor models.
//
message LogicalLaneBoundary
{
    // The ID of the lane boundary.
    //
    // \rules
    // is_globally_unique
    // \endrules
    //
    optional Identifier id = 1;

    // points making up the lane boundary.
    // The boundary must be defined in the same direction as the reference
    // line. So S positions should increase along the line. Note that S
    // positions will not always increase strictly monotonically.
    // Example:
    //                |---------\
    //                |          \
    //  /---boundary--|           \------------
    // /
    // ---------- reference line --------------
    // At the place where the boundary suddenly increases, two points will have
    // the same S coordinate.
    //
    repeated LogicalBoundaryPoint boundary_line = 2;

    // The reference line for this boundary.
    //
    // The reference line is used as a coordinate system for this boundary.
    // All points of this LogicalLaneBoundary must have S coordinates in the
    // range [sStart,sEnd].
    //
    // The reference line should roughly have the same shape as the boundary, so
    // that S coordinates continually increase along the lane.
    //
    optional Identifier reference_line_id = 3;

    // The classification of the lane boundary.
    //
    optional LaneBoundary.Classification classification = 4;

    // Optional external reference to the lane boundary source.
    //
    // \note For OpenDRIVE, there is no direct possibility to reference the
    //       RoadMark, as there is no unique identifier in this sub-object.
    //
    // \note For non-ASAM Standards, it is implementation-specific how
    //       source_reference is resolved.
    //
    // \note The value has to be repeated because one object may be derived
    //       from more than one origin source, for example, from a scenario file
    //       and from sensors.
    //
    repeated ExternalReference source_reference = 5;

    // A point on the boundary
    //
    message LogicalBoundaryPoint {

        // The position of the \c LaneBoundaryPoint.
        //
        optional Vector3d position = 1;

        // S position of the LaneBoundaryPoint, measured along the parent's
        // reference_line_id.
        //
        optional double s_position = 2;

        // T position of the LaneBoundaryPoint, measured along the parent's
        // reference_line_id.
        //
        optional double t_position = 3;
    }
}

//
// \brief A logical lane in the road network.
//
// A logical lane is part of a road. Compared to a physical lane (OSI type
// \c Lane), its existence doesn't hinge on the existence of road markings. So
// e.g. a narrow urban road with two driving directions but no road markings
// in-between would be presented as two LogicalLanes, but only one Lane. So one
// Lane can consist of multiple LogicalLanes. E.g. on intersections, each
// driving path is one LogicalLane, but the whole area is one \c Lane of type
// \c #TYPE_INTERSECTION.
//
// If OSI is generated from OpenDRIVE, then LogicalLanes map directly to
// OpenDRIVE lanes. However, it is allowed to merge multiple consecutive
// OpenDRIVE lanes with the same type into one OSI LogicalLane: if an OpenDRIVE
// lane has a single successor, which has the same lane type, and this
// successor has only one predecessor (so no lane merging or splitting) then
// the two lanes may be presented as one continuous LogicalLane. This may be
// done recursively.
//
// The reference line pointed to by reference_line_id defines an ST coordinate
// system for the lane. This ST coordinate system is used to describe positions
// on the lane.
//
message LogicalLane
{
    // The ID of the logical lane.
    //
    // \note Note ID is global unique.
    //
    // \rules
    // is_globally_unique
    // \endrules
    //
    optional Identifier id = 1;

    // The type of the logical lane.
    //
    optional Lane.Classification.Subtype type = 2;

    // Optional external reference to the lane source.
    //
    // The external reference points to the source of the lane, if it is derived
    // from one or more objects or external references.
    //
    // For example, to reference a lane defined in an OpenDRIVE map
    // the items should be set as follows:
    // * reference = URI to map, can remain empty if identical with definiton
    //               in \c GroundTruth::map_reference
    // * type = "net.asam.opendrive"
    // * identifier[0] = id of t_road
    // * identifier[1] = s of t_road_lanes_laneSection
    // * identifier[2] = id of t_road_lanes_laneSection_left_lane,
    //                         t_road_lanes_laneSection_right_lane
    //
    // \note For non-ASAM Standards, it is implementation-specific how
    //       source_reference is resolved.
    //
    // \note The value has to be repeated, because one lane segment may be
    //       derived from more than one origin segment. Multiple sources
    //       may be added as reference as well, for example, a map and sensors.
    //
    repeated ExternalReference source_reference = 3;

    // Reference to the physical lane this logical lane belongs to.
    //
    // This makes it possible to get detailed information on the physical lane
    // properties, e.g. the visual colors of the boundaries, the road
    // condition, etc..
    //
    // TODO Should this be a repeated field? Imagine the following scenario:
    // ---------------------------------
    //  l1                       l2
    // ----------    l3        ---------
    //  l4                       l5
    // ---------------------------------
    //
    // In this case, we have five physical lanes: l1, l2, l4 and l5 where a
    // lane marking is present. And l3 is one lane covering the whole road
    // (because no road marking is present).
    //
    // Now there are two basic possibilities to define the logical lanes:
    // - There could be two logical lanes: one encompassing l4, part of l3 and
    //   l5; another encompassing l2, part of l3 and l1. In this case, one
    //   logical lane can map to a number of physical lanes, and the mapping
    //   should include s positions, so it is clear which part of the logical
    //   lane maps to which physical lane.
    // - There could be 6 logical lanes: l1, l2, l4, l5 and two lanes for each
    //   halve of l3. Then each logical lane would map to a single physical
    //   lane, but logical lanes would have to be split each time a lane
    //   marking appears or disappears.
    //
    optional Identifier physical_lane_id = 4;

    // The reference line for this logical lane
    //
    // The reference line is used as a coordinate system on this lane.
    //
    // The reference line should roughly have the same shape as the lane, so
    // that S coordinates continually increase/decrease along the lane. It is
    // not required that the reference line has the same direction as the
    // driving direction of the lane.
    //
    // Neighbouring lanes are strongly encouraged to use the same
    // reference_line, so that vehicles that are next to each other on
    // neighbouring lanes have comparable S positions.
    //
    optional Identifier reference_line_id = 5;

    // Start S position of the lane. Must be in range [sStart,sEnd] of the
    // reference line.
    //
    optional double start_s = 6;

    // End S position of the lane. Must be in range [sStart,sEnd] of the
    // reference line.
    // end_s > start_s
    //
    optional double end_s = 7;

    // Definition of the intended driving direction.
    //
    // \c true means driving direction is according to ascending S position.
    // \c false means driving direction is according to descending S position.
    //
    optional bool reference_line_is_driving_direction = 8;

    // Lanes that are directly right of this lane, without gap or overlap.
    // "Right" is in definition direction (not driving direction), so right lanes
    // have smaller T coordinates.
    //
    repeated LaneRelation right_adjacent_lane = 9;

    // Lanes that are directly left of this lane, without gap or overlap.
    // "Left" is in definition direction (not driving direction), so left lanes
    // have larger T coordinates.
    //
    repeated LaneRelation left_adjacent_lane = 10;

    // Lanes that partially or completely overlap this lane. Only overlaps
    // laterally larger than 5cm are considered overlaps for the purpose of
    // this relation.
    //
    repeated LaneRelation overlapping_lane = 11;

    // Right boundary of this lane.
    // References to LogicalLaneBoundary elements.
    // All LogicalLaneBoundary elements referenced here must refer to the same
    // ReferenceLine as this lane.
    // The boundaries together must cover the whole length of the lane (the
    // range [start_s,end_s]) without gap or overlap.
    //
    // TODO Is it allowed for the boundaries to be longer than the lane?
    // Theoretically, this could be done. Then the user would have to limit the
    // boundary itself to [start_s,end_s].
    //
    repeated Identifier right_boundary_id = 12;

    // Left boundary of this lane.
    // References to LogicalLaneBoundary elements.
    // All LogicalLaneBoundary elements referenced here must refer to the same
    // ReferenceLine as this lane.
    // The boundaries together must cover the whole length of the lane (the
    // range [start_s,end_s]) without gap or overlap.
    //
    // TODO Is it allowed for the boundaries to be longer than the lane?
    // Theoretically, this could be done. Then the user would have to limit the
    // boundary itself to [start_s,end_s].
    //
    repeated Identifier left_boundary_id = 13;

    // Lanes that directly are connected to this lane at the beginning
    //
    repeated LaneConnection predecessor_lane = 14;

    // Lanes that directly are connected to this lane at the end
    //
    repeated LaneConnection successor_lane = 15;

    // Connection to another lane (predecessor or successor)
    //
    message LaneConnection {

        // Id of the other logical lane that is connected
        //
        optional Identifier other_lane_id = 1;

        // If true: LaneConnection is at the beginning of the other lane
        // If false: LaneConnection is a the end of the other lane
        //
        optional bool at_begin_of_other_lane = 2;

    }

    // Relation of this lane to another logical lane
    //
    message LaneRelation {

        // Id of the other logical lane
        //
        optional Identifier other_lane_id = 1;

        // Start s position of the relation
        //
        optional double start_s = 2;

        // End s position of the relation
        //
        // Requirement: end_s > start_s
        //
        optional double end_s = 3;

        // Start s position of the relation on the other lane.
        //
        // This is the same place as start_s, but measured along the reference
        // line of the other lane.
        //
        optional double start_s_other = 4;

        // End s position of the relation on the other lane.
        //
        // This is the same place as end_s, but measured along the reference
        // line of the other lane.
        //
        // Note: end_s_other might be smaller than start_s_other
        //
        optional double end_s_other = 5;
    }
}

// TODO Traffic Agents also need the physical area of an intersection. This
// should be added to physical lanes of type TYPE_INTERSECTION.

